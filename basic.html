<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GOD MODE: INFINITE SCALING</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; cursor: crosshair; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none; }
        .stats { font-size: 18px; margin-bottom: 5px; font-weight: bold; color: #00ff88; }
        #weapon-tag { color: #ffff00; font-size: 24px; text-shadow: 0 0 10px #ff0; }
        #level-up { 
            position: absolute; width: 100%; top: 20%; text-align: center; 
            color: #ff0055; font-size: 40px; font-weight: bold; display: none;
            text-shadow: 0 0 20px #ff0055; animation: blink 0.5s infinite;
        }
        @keyframes blink { 0% {opacity: 1;} 50% {opacity: 0.2;} 100% {opacity: 1;} }
        #boss-hud { display: none; position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 60%; }
        #boss-bar { width: 100%; height: 15px; background: #300; border: 2px solid #f00; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stats">KILLS: <span id="kills">0</span></div>
        <div class="stats">ENEMY HP MULTIPLIER: x<span id="multiplier">1.0</span></div>
        <div id="weapon-tag">MODE: CONTINUOUS RAIL</div>
        <div style="font-size: 12px; color: #aaa;">[Q] SWAP | [LMB] UNLIMITED FIRE</div>
    </div>

    <div id="level-up">ENEMIES EVOLVING...</div>

    <div id="boss-hud">
        <div id="boss-bar"><div id="boss-inner" style="width: 100%; height: 100%; background: #f00;"></div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth; canvas.height = window.innerHeight;

let player = { x: canvas.width/2, y: canvas.height/2, hp: 100, kills: 0, weapon: 'rail', shake: 0 };
let enemies = [], flames = [], beams = [], drones = [], droneProjectiles = [], boss = null;
let keys = {}, mouse = { x: 0, y: 0, down: false };
let enemyHpBase = 30; // Base health
let difficultyLevel = 1;

for(let i=0; i<3; i++) { drones.push({ angle: (Math.PI*2/3)*i, dist: 70, shootCD: 0 }); }

window.onkeydown = e => { 
    keys[e.code] = true; 
    if(e.code === 'KeyQ') {
        player.weapon = player.weapon === 'flame' ? 'rail' : 'flame';
        document.getElementById('weapon-tag').innerText = `MODE: ${player.weapon.toUpperCase()}`;
    }
};
window.onkeyup = e => keys[e.code] = false;
window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
window.onmousedown = e => { if(e.button === 0) mouse.down = true; if(e.button === 2) doDash(); };
window.onmouseup = e => { if(e.button === 0) mouse.down = false; };
window.oncontextmenu = e => e.preventDefault();

function doDash() {
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    player.x += Math.cos(ang) * 250; player.y += Math.sin(ang) * 250;
}

function update() {
    if(player.hp <= 0) location.reload();
    if (keys['KeyW']) player.y -= 7; if (keys['KeyS']) player.y += 7;
    if (keys['KeyA']) player.x -= 7; if (keys['KeyD']) player.x += 7;

    beams = [];
    if (mouse.down) {
        if(player.weapon === 'rail') {
            player.shake = 5;
            let x = player.x, y = player.y, ang = Math.atan2(mouse.y-y, mouse.x-x), pts = [{x, y}];
            for(let i=0; i<4; i++) {
                let nx = x + Math.cos(ang)*2000, ny = y + Math.sin(ang)*2000;
                if (nx<0 || nx>canvas.width) { let hx=nx<0?0:canvas.width; ny=y+Math.sin(ang)*((hx-x)/Math.cos(ang)); nx=hx; ang=Math.PI-ang; }
                else if (ny<0 || ny>canvas.height) { let hy=ny<0?0:canvas.height; nx=x+Math.cos(ang)*((hy-y)/Math.sin(ang)); ny=hy; ang=-ang; }
                checkHit(x, y, nx, ny); x=nx; y=ny; pts.push({x, y});
            }
            beams.push({ pts });
        } else {
            for(let i=0; i<3; i++) {
                const a = Math.atan2(mouse.y-player.y, mouse.x-player.x) + (Math.random()-0.5)*0.5;
                flames.push({x: player.x, y: player.y, vx: Math.cos(a)*15, vy: Math.sin(a)*15, life: 30});
            }
        }
    }

    drones.forEach(d => {
        d.angle += 0.05; d.x = player.x + Math.cos(d.angle)*d.dist; d.y = player.y + Math.sin(d.angle)*d.dist;
        let target = enemies[0] || boss;
        if(target && d.shootCD <= 0) {
            let ta = Math.atan2(target.y-d.y, target.x-d.x);
            droneProjectiles.push({x: d.x, y: d.y, vx: Math.cos(ta)*15, vy: Math.sin(ta)*15, life: 100});
            d.shootCD = 10;
        }
        if(d.shootCD > 0) d.shootCD--;
    });

    droneProjectiles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life--;
        enemies.forEach(en => { if(Math.hypot(p.x-en.x, p.y-en.y)<25) { en.hp -= 15; p.life=0; } });
        if(p.life <= 0) droneProjectiles.splice(i, 1);
    });

    flames.forEach((f, i) => { 
        f.x += f.vx; f.y += f.vy; f.life--; 
        enemies.forEach(en => { if(Math.hypot(f.x-en.x, f.y-en.y)<40) en.hp -= 4; });
        if(f.life <= 0) flames.splice(i, 1); 
    });

    enemies.forEach((en, i) => {
        let a = Math.atan2(player.y-en.y, player.x-en.x);
        en.x += Math.cos(a)*4.5; en.y += Math.sin(a)*4.5;
        if(Math.hypot(player.x-en.x, player.y-en.y)<25) player.hp -= 0.5;
        if(en.hp <= 0) { 
            enemies.splice(i, 1); player.kills++; 
            checkDifficulty();
        }
    });

    if(boss) {
        let a = Math.atan2(player.y-boss.y, player.x-boss.x); boss.x += Math.cos(a)*3; boss.y += Math.sin(a)*3;
        if(boss.hp <= 0) { boss = null; document.getElementById('boss-hud').style.display='none'; }
    }
    player.shake *= 0.8;
}

function checkDifficulty() {
    document.getElementById('kills').innerText = player.kills;
    // Every 10 kills, increase health multiplier
    if(player.kills % 10 === 0) {
        difficultyLevel += 0.2;
        document.getElementById('multiplier').innerText = difficultyLevel.toFixed(1);
        showLevelUp();
    }
    if(player.kills % 30 === 0) spawnBoss();
}

function showLevelUp() {
    const el = document.getElementById('level-up');
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 1500);
}

function checkHit(x1, y1, x2, y2) {
    let targets = boss ? [boss, ...enemies] : enemies;
    targets.forEach(en => { if(distToSeg(en.x, en.y, x1, y1, x2, y2) < 40) en.hp -= 8; });
}
function distToSeg(px, py, x1, y1, x2, y2) {
    let l2 = Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2); if (l2 == 0) return Math.hypot(px-x1, py-y1);
    let t = Math.max(0, Math.min(1, ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2));
    return Math.hypot(px - (x1 + t*(x2-x1)), py - (y1 + t*(y2-y1)));
}

function spawnEnemy() { 
    if(!boss) {
        enemies.push({
            x: Math.random()*canvas.width, y: -50, 
            hp: enemyHpBase * difficultyLevel, 
            maxHp: enemyHpBase * difficultyLevel 
        }); 
    }
    setTimeout(spawnEnemy, 400); 
}
function spawnBoss() { 
    let bHp = 2000 * difficultyLevel;
    boss = {x: canvas.width/2, y: -100, hp: bHp, max: bHp}; 
    document.getElementById('boss-hud').style.display='block'; 
}

function draw() {
    ctx.save(); if(player.shake > 1) ctx.translate((Math.random()-0.5)*player.shake, (Math.random()-0.5)*player.shake);
    ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0, 0, canvas.width, canvas.height);

    beams.forEach(b => {
        ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 15; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
        ctx.beginPath(); ctx.moveTo(b.pts[0].x, b.pts[0].y); b.pts.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 4; ctx.stroke(); ctx.shadowBlur = 0;
    });

    ctx.globalCompositeOperation = 'lighter';
    flames.forEach(f => { ctx.fillStyle = `rgba(255, ${f.life*8}, 0, 0.8)`; ctx.beginPath(); ctx.arc(f.x, f.y, 25-f.life/2, 0, Math.PI*2); ctx.fill(); });
    ctx.globalCompositeOperation = 'source-over';

    droneProjectiles.forEach(p => { ctx.fillStyle = '#ff00ff'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill(); });
    drones.forEach(d => { ctx.fillStyle = '#00ff88'; ctx.shadowBlur = 10; ctx.shadowColor = '#00ff88'; ctx.fillRect(d.x-6, d.y-6, 12, 12); ctx.shadowBlur = 0; });

    enemies.forEach(en => { 
        ctx.fillStyle='#0f0'; ctx.beginPath(); ctx.arc(en.x, en.y, 18, 0, Math.PI*2); ctx.fill(); 
        // Health bar for tanky enemies
        ctx.fillStyle='#333'; ctx.fillRect(en.x-15, en.y-25, 30, 4);
        ctx.fillStyle='#0f0'; ctx.fillRect(en.x-15, en.y-25, (en.hp/en.maxHp)*30, 4);
    });

    if(boss) { 
        ctx.fillStyle='#f00'; ctx.beginPath(); ctx.arc(boss.x, boss.y, 80, 0, Math.PI*2); ctx.fill(); 
        document.getElementById('boss-inner').style.width = (boss.hp/boss.max*100) + "%";
    }
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(player.x, player.y, 15, 0, Math.PI*2); ctx.fill();
    ctx.restore(); update(); requestAnimationFrame(draw);
}
spawnEnemy(); draw();
</script>
</body>
</html>